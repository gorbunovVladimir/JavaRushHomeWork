package com.javarush.test.level22.lesson13.task02;

import java.io.*;

/* Смена кодировки
В метод main первым параметром приходит имя файла, тело которого в кодировке Windows-1251.
В метод main вторым параметром приходит имя файла, в который необходимо записать содержимое первого файла в кодировке UTF-8.
*/
public class Solution {
    static String win1251TestString = "РќР°СЂСѓС€РµРЅРёРµ РєРѕРґРёСЂРѕРІРєРё РєРѕРЅСЃРѕР»Рё?"; //only for your testing

    public static void main(String[] args) throws IOException {
        /*BufferedReader reader=new BufferedReader(new FileReader(args[0]));
        byte[]buffer=args[0].getBytes("Windows-1251");
        BufferedWriter writer=new BufferedWriter(new FileWriter(args[1]));
        writer.write(new String(buffer, "UTF-8"));*/
        /*FileInputStream fis1 = new FileInputStream("D:\\temp.txt");
        FileOutputStream fos = new FileOutputStream("D:\\temp2.txt");*/
        FileInputStream fis1 = new FileInputStream(args[0]);
        FileOutputStream fos = new FileOutputStream(args[1]);
        byte[]buffer = new byte[fis1.available()];
        fis1.read(buffer);
        String s = new String(buffer,"UTF-8");
        buffer = s.getBytes("Windows-1251");
        fos.write(buffer);
        fis1.close();
        fos.close();
    }
}
/*Проблема в том, что в лекциях методы не очень ясно демонстрируются, если я правильно помню. Когда мы вот так String s = new String(buffer, UTF); получаем новую строку, то UTF - это не кодировка массива байт, а кодировка, согласно которой мы этот массив байт хотим переделать в строку. В документации четко написано для этого конструктора: Constructs a new String by decoding the specified array of bytes using the specified charset. Тут ничего нет о том, что указанный charset - это тот, в котором записан массив. Наоборот, это тот, согласно которого мы этот массив меняем в строку.

файл не имеет кодировок
байты, которые лежат в файле, имеют кодировку.
Поэтому, имеем файл с байтами, которые имеют кодировку Windows-1251.
Нужно их вычитать и сконвертировать в UTF-8, а потом эти новые сконвертированные байты записать в другой файл.

Почитайте тему по этой задаче на инфоджавараше, там тоже никто не понимает) Если правильно помню, рассуждал примерно так: строка win1251TestString - это то, в каком виде у нас наша строка будет в исходном файле. Нам нужно изменить ее так, чтобы она в файле читалась нормально (второй файл тоже в Windows-1251, хотя это явно не указано). Поэтому считываем строку, приводим ее к нормальному виду в UTF, а чтобы она нормально записалась, снова приводим ее к Windows-1251.

Попытаюсь переформулировать задание так: берем входной файл, в котором у нас выбрана кодировка Windows-1251, и записываем туда строчку вида
«РќР°СЂСѓС€РµРЅРёРµ РєРѕРґРёСЂРѕРІРєРё РєРѕРЅСЃРѕР»Рё?»
Нам нужно написать программу, которая делает эту строчку нормально читаемой. Для этого она должна взять эту строку, преобразовать ее в UTF-8, а затем записать ее в выходной файл в кодировке Windows-1251. Если у этого выходного файла выбрана кодировка Windows-1251, то мы увидим в нем нормальную строку вида
«Нарушение кодировки консоли?»
Иными словами, win1251TestString — это то, что мы бы увидели в Windows, если бы попытались
открыть там в кодировке Windows-1251 файл со строкой «Нарушение кодировки консоли?», записанной в кодировке UTF-8.

Задача как обычно — с приколом.
Не надо было писать в файл предложенную строку с ошибкой.
Запишите в файл с кодировкой CP1251 нормальный текст — и получите на выходе нормальный текст в кодировке UTF8.
А предложенная строка в тексте и содержит информацию о том, что это специально сделано.
*/