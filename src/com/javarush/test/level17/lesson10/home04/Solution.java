package com.javarush.test.level17.lesson10.home04;

/* Синхронизированные методы
Установить модификатор synchronized только тем методам, которым необходимо
*/

public class Solution {
    private double param = Math.random();

    private void method0() {
        double i = method3();
    }
    // синхронизируем так как вызывается метод 0 который вызывает переменную класса param
    protected synchronized void method1(String param1) {
        Solution solution = new Solution();
        solution.method0();
    }

    public void  method2(int param1) {
        param1++;
    }
    // синхронизируется так как вызывается переменная класса param
    synchronized double method3() {
        double random = Math.random();
        return random + param;
    }
    //нужна синхронизация так как StringBuilder не имеет внутренней синхронизации.
    /*Класс StringBuilder идентичен классу StringBuffer и обладает большей производительностью. Однако он не синхронизирован, поэтому его не нужно использовать в тех случаях, когда к изменяемой строке обращаются несколько потоков. чтобы такого не было, синхронизируют метод
stackoverflow.com/questions/355089/stringbuilder-and-stringbuffer
     если метод не будет синхронизирован, то данные что в стрингбилдере возможно будут изменены другим тредом при исполненнии аппендов или создании билдера, так как это все в куче не атомарная операция, которая будет исполнена за несколько переключений между конвеерами в CPU.
     не относится к локальным переменным треда? Метод — общий ресурс. Суть вопроса состоит в том, что пока твой тред зашел в метод, потом CPU переключился на другой тред, и он также зашел в тот же метод, и твой аппенд уже изменился, потом CPU переключился обратно на твой тред, и уже беда, в твоем StringBuilder — е уже другие данные, и если твой метод не воид то что вернет твой метод ???
в твоем случае медот ран и есть метод треда, а метод4, метод обьекта что может меняться другими тредами, при исполнении.
*/
    private synchronized void method4() {
        new StringBuilder().append(1).append(1).append(1).append(1);
    }
    //StringBuffer не надо синхронизовать
    protected void method5(String param2) {
        new StringBuffer().append(param2).append(param2).append(param2);
    }
    //есть вывод на консоль.
    public synchronized String method6(int param2) {
        System.out.println("Thinking....");
        method7(5e-2);
        return "Got it!";
    }

    String method7(double param2) {
        return "" + param2;
    }

}
/*
 * 1) method4() нужно синхронизировать, потому что создается новый объект типа StringBuilder(), который не имеет встроенной синхронизации
 2) method5() не нужно синхронизировать, потому что создается новый объект типа StringBuffer(), который в себе имеет встроенную синхронизацию
 3) method3() нужно синхронизировать, потому он доступается к общему private double param = Math.random(), который может использовать любой метод внутри класса Solution
 4) method0() не нужно синхронизировать, потому он вызывает в себе method3(), который в свою очередь синхронизированный
 5) method2() не нужно синхронизировать, потому что он не создает новых объектов и не изменяет общие ресурсы и не вызывает других методов
 6) method1() нужно синхронизировать, потому что он вызывает в себе метод, который не синхронизированный, чтоб не получилось так что double i = method3() будет иметь значение из другого потока, а не из вашего
 7) method7() не нужно синхронизировать, потому что он не создает новых объектов и не изменяет общие ресурсы и не вызывает других методов
 8) method6() нужно синхронизировать, потому что он вызывает в себе метод, который не синхронизированный, и у него есть вывод в консоль

 0: создает локальную переменную, никаких проблем, а про вызов метода3 читай дальше

 1: что мы здесь имеем:
 рассмотрим вариант когда мы создали объект класса Solution, потом мы его поочередно передали в большое количество потоков и запустили те потоки, каждый поток вызовет этот метод и вот что мы получим:
 каждый поток будет заново создавать локальную переменную solution, а она при создании присваивает значение своей переменной param, и пока один поток создаст объект и попробует вызвать метод метод0 а тот в свою очередь вызвать метод3 где обращается к переменной param, другой поток заново создаст эту локальную переменную solution и значение param уже будет новым, соответственно в первом потоке метод3 получит значение которое установилось вторым потоком.
 Сумбурно вышло но надеюсь что поймете, можно было бы нарисовать, на изображении будет наглядней.
 Ну надеюсь теперь понятно что с этим методом делать :)
 2: ничего не лочится, param1 передается по значению
 3: идет обращение к локальной переменной param, а вдруг ее кто то изменит :), а из метода1 видно что изменить ее могут
 4: ну это же StringBuilder, про это писалось
 5: ну это же StringBuffer, про это тоже писалось :)
 6: если не залочить тогда в консоль сообщения будут выводиться вперемешку
 7: ничего не лочится, param2 передался по значению
 */
